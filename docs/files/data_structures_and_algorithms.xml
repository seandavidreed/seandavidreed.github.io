<deck name="Data Structures and Algorithms"><fields><text name='Front' sides='10' ></text><tex name='TeX' sides='01' ></tex><text name='Back' sides='01' ></text></fields><cards><card><field name='Front'>Given a parent node in a min-heap, how do we access its left child? Right child?</field><field name='TeX'></field><field name='Back'>Left child: take the index of the parent node in the array and multiply it be 2 to produce the index of the left child.

Right child: same method as for left child plus 1.</field></card><card><field name='Front'>What are the functions associated with a graph?</field><field name='TeX'></field><field name='Back'>insertVertex()
insertEdge()

removeVertex()
removeEdge()

incidentEdges()
areAdjacent()

origin()
destination()</field></card><card><field name='Front'>What makes a Binary Tree a Binary Search Tree?</field><field name='TeX'></field><field name='Back'>A binary tree is a binary search tree if and only if every left node is smaller and every right node is larger than their parent node.</field></card><card><field name='Front'>What are two common ways to handle collisions in a Hash Table?</field><field name='TeX'></field><field name='Back'>1. Separate Chaining - where each bucket is the head of a linked list.
2. Probe-Based Hashing - where, upon collision, we iterate from that bucket until we reach an empty one.</field></card><card><field name='Front'>What problem created by Linear Probing does Double Hashing solve?</field><field name='TeX'></field><field name='Back'>Linear probing can tend to cause Primary Clustering, where keys map to contiguous buckets. As a cluster grows, it becomes more likely we will have to probe each time we want to insert a key-value pair.</field></card><card><field name='Front'>Graph: What is the objective of Kruskal's Algorithm?</field><field name='TeX'></field><field name='Back'>To find the minimum spanning tree of a graph.</field></card><card><field name='Front'>What makes a data structure a Tree?</field><field name='TeX'></field><field name='Back'>It must have a root.
It must have directed edges.
It must not have a cycle.
A tree is a rooted, directed, acyclic data structure.</field></card><card><field name='Front'>What is the height balance factor of a node in a BST?</field><field name='TeX'></field><field name='Back'>It is the difference in height between its two subtrees.</field></card><card><field name='Front'>What are the average-case runtimes of BST functions? Worst-case?</field><field name='TeX'>
\text{find, insert, and remove}\\
\text{Average: }\Theta(\lg n)\\
\text{Worst: }O(n)</field><field name='Back'>Average case occurs when the BST is balanced or nearly balanced. Worst case occurs when the BST is merely a linked list.</field></card><card><field name='Front'>Merge Sort</field><field name='TeX'>O(n\lg n)</field><field name='Back'>The process of recursively splitting data in half will naturally make a call stack O(log n) layers deep, and there is O(n) overhead work to be done at each of those levels.</field></card><card><field name='Front'>What are the minimum edges in a connected graph?</field><field name='TeX'>m = n - 1</field><field name='Back'>m is number of edges.
n is number of nodes.</field></card><card><field name='Front'>Graph BFS Traversal: what is the difference between a discovery edge and cross edge?</field><field name='TeX'></field><field name='Back'>A discovery edge connects an expanded vertex to an unexpanded vertex while a cross edge connects an expanded vertex to an expanded vertex. When you are expanding a vertex, you are generating discovery edges; the edge you traveled to get to that vertex is a cross edge.</field></card><card><field name='Front'>What is an Onto Function</field><field name='TeX'></field><field name='Back'>A hash function that maps all our data perfectly onto a hash table, filling every bucket.</field></card><card><field name='Front'>What three components do we need to make a Hash Table?</field><field name='TeX'></field><field name='Back'>1. Hash function
2. Array
3. Collision Handling</field></card><card><field name='Front'>What make a Binary Tree full?</field><field name='TeX'></field><field name='Back'>Every parent node has two children.</field></card><card><field name='Front'>What is the runtime of Insertion Sort?</field><field name='TeX'>O(n^2) = \displaystyle\sum_{i=1}^{n}i = \frac{1}{2}n^2 \times \frac{1}{2}n</field><field name='Back'>A naive algorithm that inserts items from an unsorted list into their correct, sorted positions in a new list.</field></card><card><field name='Front'>What are four types of tree traversal?</field><field name='TeX'></field><field name='Back'>Preorder Traversal: Shout, Left, Right
In-Order Traversal: Left, Shout, Right
Postorder Traversal: Left, Right, Shout
Level Order Traversal: visit a level at a time</field></card><card><field name='Front'>Queue as Array: pop()</field><field name='TeX'>O(1)*</field><field name='Back'>Amortized time since the array will periodically need to be resized.</field></card><card><field name='Front'>Graph: What is the runtime of Prim's Algorithm?</field><field name='TeX'>O(m\lg n)</field><field name='Back'></field></card><card><field name='Front'>BST Balancing: what is the runtime of a rotation?</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>What is the only difference between Dijkstra's Algorithm and Prim's Algorithm?</field><field name='TeX'></field><field name='Back'>Dijkstra's is different from Prim's in that each outbound edge from the starting partition has its weight updated to the sum of weights from the starting node.</field></card><card><field name='Front'>What is a balanced BST?</field><field name='TeX'></field><field name='Back'>A BST where every node has a height balance factor with a magnitude of 0 or 1.</field></card><card><field name='Front'>Disjoint Sets: What is path compression?</field><field name='TeX'></field><field name='Back'>It's where you move through an UpTree making each node point to the root. In practice, this is often done for a single path when it must be accessed anyway.</field></card><card><field name='Front'>What is the maximum number of edges in a simple graph?</field><field name='TeX'>\frac{n(n-1)}{2} \approx O(n^2)</field><field name='Back'></field></card><card><field name='Front'>Queue as Linked List: empty()</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>How is a min-heap stored in memory?</field><field name='TeX'></field><field name='Back'>As an array.</field></card><card><field name='Front'>Graph: How is an Edge List implemented? When is it most useful?</field><field name='TeX'></field><field name='Back'>The graph is maintained as merely a hash table of pairs representing edges. This implementation is simple and is especially useful when you have a simple, directed graph that you need to build quickly and that requires minimal manipulation.</field></card><card><field name='Front'>Graph: What are two use cases of a BFS Traversal?</field><field name='TeX'></field><field name='Back'>1. Detecting disjoint graphs
2. Detecting cycles</field></card><card><field name='Front'>What are two ways to implement a Dictionary data structure? What are their distinct advantages?</field><field name='TeX'></field><field name='Back'>1. AVL Tree - offers range-finding and nearest neighbor (creates an ordered dict)
2. Hash Table - offers very fast lookups and is the superior choice if we always have the exact key and we only want to do lookups (creates an unordered dict).</field></card><card><field name='Front'>What is meant by the "order" of a B-Tree?</field><field name='TeX'></field><field name='Back'>Order refers to the maximum number of children a node can have, denoted as m.</field></card><card><field name='Front'>What makes a Binary Tree complete?</field><field name='TeX'></field><field name='Back'>The tree is perfect up to the last level, where all leaf nodes are pushed left.</field></card><card><field name='Front'>How is BFS Traversal different when used on a graph instead of a tree?</field><field name='TeX'></field><field name='Back'>A graph does not have an obvious starting point, it isn't ordered, and there isn't a notion of completeness. Therefore, when performing BFS traversal on a graph, we have to keep track of extra information like which edges have already been traveled, nodes visited.</field></card><card><field name='Front'>Trees: what is the difference between a traversal and a search?</field><field name='TeX'></field><field name='Back'>A traversal visits every single node in the data structure while a search visits only the nodes necessary to find a target node.</field></card><card><field name='Front'>What is the goal of a B-Tree?</field><field name='TeX'></field><field name='Back'>To minimize the number of reads. The goal of a B-Tree is to have a data structure that will perform well both in memory and in storage.</field></card><card><field name='Front'>What makes a Binary Tree perfect?</field><field name='TeX'></field><field name='Back'>Every parent node has two children and every path is the same length.</field></card><card><field name='Front'>Queue as array: create()</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>Graph: How does DFS Traversal work (pseudocode)?</field><field name='TeX'></field><field name='Back'>1. Pick a starting vertex and push it into a stack (alternatively, rely on the recursive function calls for an implied stack).
2. Prepare an array to catalog visited vertices.
Repeat while stack is not empty:
2. Pop and Expand the first vertex, marking it as visited, 
3. Push all of its adjacent nodes into the stack.</field></card><card><field name='Front'>What are the four properties of a B-Tree?</field><field name='TeX'></field><field name='Back'>1. All keys within a node are in sorted order.
2. Each node contains no more than m - 1 keys, where m denotes the maximum number of children.
3. Each internal node has exactly one more child than key.
4. All leaf nodes are on the same level.</field></card><card><field name='Front'>What functions are associated with a Binary Search Tree? What are their worst-case runtimes?</field><field name='TeX'>\text{find: }O(h)\text{ bounded by }O(n)\\
\text{insert: }O(h)\text{ bounded by }O(n)\\
\text{remove: }O(h)\text{ bounded by }O(n)\\
\text{where h is the height of the tree}</field><field name='Back'></field></card><card><field name='Front'>Hash Tables: When would Separate Chaining be more effective than Probing with Double Hashing and vice versa?</field><field name='TeX'></field><field name='Back'>Separate Chaining is superior when handling large records.
Double Hashing is superior when speed is required.</field></card><card><field name='Front'>How many ways are there to create a BST with the same set of data?</field><field name='TeX'>n! \text{ ways}</field><field name='Back'>However, some of these result in just a linked list, which defeats the purpose of creating a BST.</field></card><card><field name='Front'>What is the difference between Sparse and Dense Graphs?</field><field name='TeX'>\text{Sparse Graphs: }m \approx n\\
\text{Dense Graphs: }m \approx n^2</field><field name='Back'>Sparse Graph: a graph where the number of edges m is close to or at the minimum for a connected graph.
Dense Graph: a graph where the number of edges m is close to or at the maximum (in our case, for simple graphs).</field></card><card><field name='Front'>Disjoint Sets: How does union by height work?</field><field name='TeX'></field><field name='Back'>We store the height of the UpTree as a negative value minus 1 at the element in the array indicated by the set identity. When peforming union by height, we then make the tree of smaller height a subtree of the larger height.</field></card><card><field name='Front'>Graph: How does Prim's Algorithm work?</field><field name='TeX'></field><field name='Back'>1. Select starting node in a graph and define it as a partition against all other nodes.
Repeat until all nodes have been visited:
2. Find the smallest weighted edge between the partitions and add that node to our starting partition.</field></card><card><field name='Front'>Graph: How is Kruskal's Algorithm implemented (pseudocode)?</field><field name='TeX'></field><field name='Back'>1. Build a Priority Queue (minHeap or sorted Array) to keep track of the edges from smallest to largest.
2. Create a disjoint set out of each vertex.
Repeat until Priority Queue is empty:
3. Remove an edge from the priority queue.
4. If the vertices in the edge don't already share a set identity, call union on them.
</field></card><card><field name='Front'>What is iterated log?</field><field name='TeX'>\lg*n := \begin{cases}
0 \quad \text{if }n \leq 1\\
1 + \lg*(\lg n) \quad \text {if }n \gt 1
\end{cases}</field><field name='Back'>It is the number of times the logarithm function must be iteratively applied before the result is less than or equal to 1.</field></card><card><field name='Front'>What are three common graph implementations?</field><field name='TeX'></field><field name='Back'>1. Edge List
2. Adjacency Matrix
3. Adjacency List</field></card><card><field name='Front'>How is it inefficient to implement disjoint sets with set elements as indices and set identities as elements?</field><field name='TeX'></field><field name='Back'>With this setup, performing a union of two sets will take Linear Time O(n), and we can do better by using UpTrees.</field></card><card><field name='Front'>What are the worst-case runtimes for insert and remove/find in a Hash Table implemented with Separate Chaining? How does satisfying SUHA change them?</field><field name='TeX'>\text{insert: }O(1)\\
\text{remove/find: }O(n)\\
\text{---}\\
\text{SUHA}\\
\text{insert: }O(1)\\
\text{remove/find: }O(\alpha)\text{ where }\alpha\text{ is the load factor of the table: }\frac{n}{N}</field><field name='Back'></field></card><card><field name='Front'>Queue as Array: push()</field><field name='TeX'>O(1)*</field><field name='Back'>Amortized time since the array will periodically need to be resized.</field></card><card><field name='Front'>What is the mechanism by which BSTs are balanced?</field><field name='TeX'></field><field name='Back'>By turning "sticks" into "mountains" through a series of rotations.</field></card><card><field name='Front'>Graph BFS Traversal: What structure is made from discovery edges?</field><field name='TeX'></field><field name='Back'>Spanning Tree: a single tree that spans the entire graph.</field></card><card><field name='Front'>How can Probe-Based Hashing be optimized?</field><field name='TeX'></field><field name='Back'>Though the use of Double-Hashing, which, upon collision, rehashes the key in a different hash function to yield a step value - we then probe from there in increments of the step value.</field></card><card><field name='Front'>What is a Binary Search Tree (BST)?</field><field name='TeX'></field><field name='Back'>An ordered binary tree where each parent node has a smaller left child node or a larger right child node or both.</field></card><card><field name='Front'>What does AVL stand for in the AVL Tree?</field><field name='TeX'></field><field name='Back'>Adelson-Velsky and Landis</field></card><card><field name='Front'>Graph: What are the edges that connect directly to a given node called?</field><field name='TeX'></field><field name='Back'>Incident Edges.</field></card><card><field name='Front'>What makes a complete Binary Tree a Min-Heap?</field><field name='TeX'></field><field name='Back'>A complete binary tree is a min-heap if every parent node is less than each of its child nodes.</field></card><card><field name='Front'>What is the Simple Uniform Hashing Assumption (SUHA)?</field><field name='TeX'>a \neq b \Rightarrow P(h(a) == h(b)) == \frac{1}{N}</field><field name='Back'>If two keys are different, then we want the probability that their hashs are equal to be 1/N, where N is the size of the Hash Table.</field></card><card><field name='Front'>Graph with Edge List: what are the runtimes of its functions?</field><field name='TeX'>\text{insertVertex(): }O(1)*\\
\text{removeVertex(): }O(m)\\
\text{incidentEdges(): }O(m)\\
\text{areAdjacent(): }O(m)</field><field name='Back'></field></card><card><field name='Front'>What are the two parts of a Hash Function?</field><field name='TeX'></field><field name='Back'>1. A hash - transforms input into an integer.
2. Compression - compress the hash into the bounds of the hash table - hash mod N.</field></card><card><field name='Front'>Graph with Adjacency Matrix: what are its functions runtimes?</field><field name='TeX'>\text{insertVertex(): }O(n)\\
\text{removeVertex(): }O(n)\\
\text{incidentEdges(): }O(n)\\
\text{areAdjacent(): }O(1)</field><field name='Back'></field></card><card><field name='Front'>Binary Search Tree: What is an In-Order Predecessor (IOP)?</field><field name='TeX'></field><field name='Back'>The previous node in an in-order traversal. The IOP will always be the rightmost node of the largest left subtree.</field></card><card><field name='Front'>What is worst-case runtime for Heap Sort?</field><field name='TeX'>O(n\lg n)\\
\text{buildHeap + removeMin}</field><field name='Back'></field></card><card><field name='Front'>What does Dijkstra's Algorithm give us?</field><field name='TeX'></field><field name='Back'>It gives us the total distances from the starting node to each other node. Each distance will be the shortest distance to reach a given node from the starting node.</field></card><card><field name='Front'>Graph with Adjacency List: what are its functions runtimes?</field><field name='TeX'>\text{insertVertex(): }O(1)\\
\text{removeVertex(): }O(\deg(v))\\
\text{incidentEdges(): }O(deg(v))\\
\text{areAdjacent(): }O(\min(\deg(v), \deg(w)))</field><field name='Back'></field></card><card><field name='Front'>What is a simple graph?</field><field name='TeX'></field><field name='Back'>A graph with no self-loops or multi-edges.</field></card><card><field name='Front'>What are the characteristics of a good Hash Function?</field><field name='TeX'></field><field name='Back'>1. It runs in Constant Time - O(1)
2. It is deterministic - the same input must always generate the same output.
3. It satisfies the SUHA - Simple Uniform Hashing Assumption.</field></card><card><field name='Front'>Disjoint Sets: How does union by size work?</field><field name='TeX'></field><field name='Back'>At the set identity index, we store the number of nodes for that set as a negative value. When performing a union, we make the tree of smaller size a subtree of the larger size, thereby increasing the height if the fewest number of nodes.</field></card><card><field name='Front'>What is the minimum number of edges in an unconnected graph?</field><field name='TeX'></field><field name='Back'>Zero</field></card><card><field name='Front'>Given a child node in a min-heap, how do we access its parent node?</field><field name='TeX'></field><field name='Back'>Take its index and divide it by 2, taking the floor of the quotient; that is the index of the parent.</field></card><card><field name='Front'>Graph: What is the degree of a node?</field><field name='TeX'></field><field name='Back'>Its quantity of incident edges.</field></card><card><field name='Front'>Graph: What is the runtime of DFS Traversal?</field><field name='TeX'>O(n + m)</field><field name='Back'>Since every node is visited at most once, we know that an edge (u, v) is scanned at most twice (or only once for directed graphs). Thus, # of edges scanned is O(m), and the overall runtime of DFS is O(n + m).</field></card><card><field name='Front'>Graph: What is a limitation of BFS?</field><field name='TeX'></field><field name='Back'>It can only find the shortest path between whatever node you start on and a target node.</field></card><card><field name='Front'>What is the runtime of Dijkstra's Algorithm?</field><field name='TeX'>O(m\lg n)</field><field name='Back'></field></card><card><field name='Front'>Graph: What is the runtime of Kruskal's Algorithm using a minHeap for the Priority Queue?</field><field name='TeX'>\text{buildHeap: }O(m)\\
\text{each removeMin call: }O(\lg m)\\
\text{total: }O(m + m\lg m)</field><field name='Back'></field></card><card><field name='Front'>What is the maximum number of edges in a graph that isn't simple?</field><field name='TeX'>+\infty</field><field name='Back'></field></card><card><field name='Front'>What is an AVL Tree?</field><field name='TeX'></field><field name='Back'>A balanced BST kept in balance through tree rotations on insert and remove.</field></card><card><field name='Front'>Graph: How does BFS traversal work (pseudocode)?</field><field name='TeX'></field><field name='Back'>1. Pick a starting vertex and load it into a queue.
2. Prepare an array to catalog visited vertices.
Repeat while queue is not empty:
2. Dequeue and Expand the first vertex, 
3. Enqueue all of its adjacent nodes, and mark them visited in visited array.</field></card><card><field name='Front'>What is a Disjoint-Set data structure?</field><field name='TeX'></field><field name='Back'>A data structure that keeps track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. Each subset is identified by an element chosen to be the set identity.</field></card><card><field name='Front'>Queue as Linked List: push()</field><field name='TeX'>O(1)</field><field name='Back'>Constant time</field></card><card><field name='Front'>Queue as Linked List: what is the runtime of pop()?</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>Queue as Array: empty()</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>Which is better: Union by Height or Union by Size?</field><field name='TeX'></field><field name='Back'>Neither - both bring about the same result, a tree of lg(n) height.</field></card><card><field name='Front'>What are the functions associated with a min-heap? What are their runtimes?</field><field name='TeX'>\text{removeMin: }O(\lg n)\\
\text{buildHeap: }O(n)\\
\text{insert: }O(\lg n)</field><field name='Back'></field></card><card><field name='Front'>What is the goal of Dijkstra's Algorithm?</field><field name='TeX'></field><field name='Back'>To find the shortest path on a graph. This algorithm will operate much like Prim's algorithm.</field></card><card><field name='Front'>Queue as Linked List: create()</field><field name='TeX'>O(1)</field><field name='Back'></field></card><card><field name='Front'>What feature of a graph will inhibit us from running a Single Source Shortest Path (SSSP) Algorithm like Dijkstra's?</field><field name='TeX'></field><field name='Back'>Negative-weighted edges.</field></card><card><field name='Front'>How is a disjoint set implemented?</field><field name='TeX'></field><field name='Back'>We keep an array where each index is a set item, the element of which stores either a pointer to some other set item in the set, or if the index is the set identity, to -1.</field></card><card><field name='Front'>What two things can we do with the elements of set identity indices to optimize disjoint sets?</field><field name='TeX'></field><field name='Back'>Instead of -1, we can store the height of the UpTree as a negative value minus 1. This allows us to perform unions by height.

We can store the number of nodes in the UpTree as a negative value. This allows us to perform union by size.</field></card><card><field name='Front'>How do AVL Trees maintain their balance?</field><field name='TeX'></field><field name='Back'>Through storing a nodes height balance factor within it and performing rotations whenever it is greater than 1 or less than -1.</field></card><card><field name='Front'>Graph: What is the runtime of BFS Traversal (worst and average case)?</field><field name='TeX'>\text{Worst Case: }O(n^2) \text{ since the graph might be fully connected}\\
\text{Average Case: }\theta(n + m) \text{ since its more common that graphs aren't fully connected}</field><field name='Back'></field></card><card><field name='Front'>Graph: What is a Minimum Spanning Tree?</field><field name='TeX'></field><field name='Back'>A tree that connects all the nodes in a graph using the minimum number of edges or using the edges with minimal weights.</field></card><card><field name='Front'>What famous problem can be solved with Dijkstra's Algorithm?</field><field name='TeX'></field><field name='Back'>Several, of course, but the one we learned about was the Landmark Path Problem.</field></card><card><field name='Front'>Graph: what does the Adjacency List implementation optimize?</field><field name='TeX'>\text{Edge List, Adjacency List}\\
\text{removeVertex(): }O(m),\ O(\deg(v))\\
\text{incidentEdges(): }O(m),\ O(\deg(v))\\
\text{areAdjacent(): }O(m),\ O(\min(\deg(v), \deg(w)))</field><field name='Back'>It optimizes the Edge List entirely (though there are some use cases where the Edge List is superior), and it is better than Adjacency Matrix in everything except determining whether two nodes are adjacent.</field></card><card><field name='Front'>Why do we want to use a heap?</field><field name='TeX'></field><field name='Back'>Given any data structure, we can build a heap out of it in O(n) time.</field></card><card><field name='Front'>Graph: what is the runtime for Kruskal's Algorithm using a sorted array for the Priority Queue?</field><field name='TeX'>\text{buildSortedArray: }O(m\lg m)\\
\text{each removeMin call: }O(1)\\
\text{total: }O(m\lg m + m)</field><field name='Back'></field></card><card><field name='Front'>Graph: What function does the Adjacency Matrix implementation optimize? What is the cost of this optimization?</field><field name='TeX'>\text{areAdjacent(): }O(1)\\
\text{at the cost of }
\text{insertVertex(): }O(n)\\
\text{removeVertex(): }O(n)\\
\text{incidentEdges(): }O(n)\\
\text{which all have linear runtime}</field><field name='Back'></field></card><card><field name='Front'>What two functions make up Heap Sort? What are their runtimes?</field><field name='TeX'>\text{buildHeap - }O(n)\\
\text{removeMin - }O(\lg n)\\
\text{Total: Heap Sort - }O(n\lg n)</field><field name='Back'></field></card><card><field name='Front'>What is a Binary Tree</field><field name='TeX'></field><field name='Back'>A tree where every node has at most two children.</field></card><card><field name='Front'>Graph: What it the objective of Prim's Algorithm?</field><field name='TeX'></field><field name='Back'>To build the minimum spanning tree over a graph.</field></card><card><field name='Front'>What is the runtime of resizing an array by doubling its capacity?</field><field name='Back'>This is the superior strategy for resizing an array.</field><field name='TeX'>O(n)</field></card><card><field name='Front'>Linear Time</field><field name='Back'>The number of operations is directly proportional to the number of data points n.</field><field name='TeX'>O(n)</field></card><card><field name='Front'>Linear Search</field><field name='TeX'>O(n)</field><field name='Back'>The number of operations is proportional to the number of inputs.</field></card><card><field name='Front'>Constant Time</field><field name='Back'>The number of operations remains constant as n inputs increase.</field><field name='TeX'>O(1)</field></card><card><field name='Front'>Polynomial Time</field><field name='TeX'>O(n^2)</field><field name='Back'>The number of operations increases exponentially as the number of data points n increases</field></card><card><field name='Front'>What is the runtime of Binary Search?</field><field name='TeX'>O(\lg n)</field><field name='Back'>Requires that the array is sorted.</field></card></cards></deck>